#include "avl.h"static ramos root=NULL;int activos = 0;ramos novo(link_cl item, ramos l, ramos r){	/*cria uma nova folha e devolve um apontador para esta*/	ramos x = NULL;	x = malloc(sizeof(Folha));	x->item = item;	x->l = l;	x->r = r;	x->peso=1;	return x;}int peso(ramos h){	/*recebe um apontador para uma folha e devolve o seu peso*/	if (h == NULL)		return 0;	return h->peso;}void percorre_avl(){	/*chama a percorre_avl_aux com o valor da root*/	percorre_avl_aux(root);}void percorre_avl_aux(ramos h){	/*percorre a arvore e imprime a informacao dos clientes ativos por ordem*/	if (h == NULL)		return;	percorre_avl_aux(h->l);	if (h->item->num_e != 0 || h->item->num_b != 0) {		printf("*");		info_cliente(h->item);	}	percorre_avl_aux(h->r);}ramos procura_avl(ramos h, link_cl item){	/*procura na arvore a folha cujo item e igual ao item recebido*/	if (h == NULL)		return NULL;	if (compara_clientes(item, h->item)==0)		return h;	if (compara_clientes(item, h->item)<0)		return procura_avl(h->l, item);	else		return procura_avl(h->r, item);}ramos rotacao_esquerda(ramos h){	/*caso a arvore esteja desiquilibrada, esta funcao e chamada e e efectuada uma rotacao da arvore	para a esquerda.*/	int peso_esquerdo, peso_direito;	ramos x = h->r;	h->r = x->l;	x->l = h;	peso_esquerdo = peso(h->l);	peso_direito = peso(h->r);	h->peso = peso_esquerdo > peso_direito ? peso_esquerdo + 1 : peso_direito + 1;	peso_esquerdo = peso(h->l);	peso_direito = peso(x->r);	x->peso = peso_esquerdo > peso_direito ? peso_esquerdo + 1 : peso_direito + 1;	return x;}ramos rotacao_direita(ramos h){	/*caso a arvore esteja desiquilibrada, esta funcao e chamada e e efectuada uma rotacao da arvore	para a direita.*/	int peso_esquerdo, peso_direito;	ramos x = h->l;	h->l = x->r;	x->r = h;	peso_esquerdo = peso(h->l);	peso_direito = peso(h->r);	h->peso = peso_esquerdo > peso_direito ? peso_esquerdo + 1 : peso_direito + 1;	peso_esquerdo = peso(x->l);	peso_direito = peso(h->r);	x->peso = peso_esquerdo > peso_direito ? peso_esquerdo + 1 : peso_direito + 1;	return x;}ramos rotacao_esq_dir(ramos h){	/*efectua uma rotação para a esquerda e de seguida um rotacao	para a direita*/	if (h==NULL)		return h;	h->l = rotacao_esquerda(h->l);	return rotacao_direita(h);}ramos rotacao_dir_esq(ramos h){	/*efectua uma rotação para a direita e de seguida um rotacao	para a esquerda*/	if (h==NULL)		return h;	h->r = rotacao_direita(h->r);	return rotacao_esquerda(h);}int balanco(ramos h){	/*verifica se a arvore esta desiquilibrada ou nao, verificando se o peso para	a esquerda e para a direita*/	if(h == NULL) return 0;		return peso(h->l) - peso(h->r);}ramos balanco_arvore(ramos h){	/*verifica qual a rotacao necessaria a realizar para a arvore ficar equilibrada*/	int factor_balanco;	if (h == NULL)		return h;	factor_balanco = balanco(h);	if (factor_balanco > 1) { 			/*caso a arvore esteja desiquilibrada para a esquerda*/		if (balanco(h->l) > 0) 				/*caso esteja a arvore esteja desiquilibrada para a esquerda*/			h = rotacao_direita(h);		else 													/*caso a arvore esteja desiquilibrada para a direita*/			h = rotacao_esq_dir(h);	}	else if (factor_balanco < -1) { /*caso a arvore esteja desiquilibrada para a direita*/		if (balanco(h->r) < 0)   			/*caso a arvore esteja desiquilibrada para a direita*/			h = rotacao_esquerda(h);		else 													/*caso esteja a arvore esteja desiquilibrada para a esquerda*/			h = rotacao_dir_esq(h);	}	else {   												/*actualiza os pesos das folhas*/		int peso_esquerdo = peso(h->l);		int peso_direito = peso(h->r);		h->peso = peso_esquerdo > peso_direito ? peso_esquerdo + 1 : peso_direito + 1;	}	return h;}ramos insereR(ramos h, link_cl item){	/*insere um novo cliente na arvore por ordem crescente das referencias*/	if (h == NULL) 														/*caso a arvore esteja vazia cria o primeiro cliente(root)*/		return novo(item, NULL, NULL);	if (compara_clientes(item, h->item) < 0)	/*caso a referencia seja menor que o da folha comparada*/		h->l = insereR(h->l, item);	else 																			/*caso a referencia seja maior que o da folha comparada*/		h->r = insereR(h->r, item);	h = balanco_arvore(h); 										/*repoe o equilibrio a arvore*/	return h;}link_cl verifica_cliente(Ref referencia){	/*verifica se um cliente existe e caso nao exista, cria um com a referencia recebida*/  link_cl ap_cliente;  ramos no;	ap_cliente = cria_cliente(referencia);  no = procura_avl(root, ap_cliente);  if (no == NULL) {    no = insereR(root, ap_cliente);		root = no;    return ap_cliente;  }  else		free(ap_cliente);    return no->item;}int apaga_arvore(){	/*chama a funcao apaga_arvore_aux, e imprime o numero de clientes activos*/	return apaga_arvore_aux(root);}int apaga_arvore_aux(ramos h){	/*apaga todas as folhas da arvore e os respectivos clientes, devolvendo o numero	de clientes ativos apagados*/	if (h==NULL)		return activos;	apaga_arvore_aux(h->l);	apaga_arvore_aux(h->r);	if (h->item->num_e != 0 || h->item->num_b != 0)		activos++;	apaga_cliente(h->item);	free(h);	return activos;}